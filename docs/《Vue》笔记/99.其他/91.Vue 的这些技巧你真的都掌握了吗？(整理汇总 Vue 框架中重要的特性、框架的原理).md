---
title: Vue 的这些技巧你真的都掌握了吗？(整理汇总 Vue 框架中重要的特性、框架的原理)
date: 2021-12-31 16:07:51
permalink: /pages/961fa6/
categories:
  - 《Vue》笔记
  - 其他
tags:
  - 
---


![banner](https://edu-guli-oss1.oss-cn-beijing.aliyuncs.com/blog/640.webp)

# 前言

文章目的昭然若揭🐱‍🐉，整理汇总 Vue 框架中重要的特性、框架的原理。

那 "前车之鉴" 从何而来？

是的，我又要讲小故事了，但这次是故事的续集。

故事第 1 集：CSS预处理器，你还是只会嵌套么 ？[2]
故事第 2 集：【自适应】px 转 rem，你还在手算么？[3]

为什么说是续集，因为这些都是同一大佬问的，在此感谢大佬，天降素材🤣。

故事续集

大佬：有看过 Vue 源码么？

我：嗯嗯，看过。

大佬：那大概讲一讲 nextTick 的底层实现 ？

我：停顿了大概10s，说了句忘了。（理不直气还壮）

大佬：噢噢，没事。（内心大概已经放弃对我知识面的挖掘）

因为是视频面试，强装自信的尴尬从屏幕中溢出，这大概就是普通且自信🤦‍♂️？装X失败案例引以为戒，能写出续集的面试结果不提也罢。

这次面试打击还是蛮大的，考察内容全面且细节。面试后一直在整理 Vue 相关的知识点，所以不会将nextTick实现单独成文，只是收录在下方试题中。前车之鉴可以为鉴，大家可以把本篇文章当测验，考察自己是否对这些知识点熟练于心。

万字长文，持续更新，若有遗漏知识点，后续会补充。


# 题目

## 优点
1.创建单页面应用的轻量级Web应用框架
2.简单易用
3.双向数据绑定
4.组件化的思想
5.虚拟DOM
6.数据驱动视图

## 缺点
不支持IE8（现阶段只能勉强凑出这么半点😂）

# SPA 的理解

SPA是Single-Page-Application的缩写，翻译过来就是单页应用。在WEB页面初始化时一同加载Html、Javascript、Css。一旦页面加载完成，SPA不会因为用户操作而进行页面重新加载或跳转，取而代之的是利用路由机制实现Html内容的变换。

##优点
1.良好的用户体验，内容更改无需重载页面。
2.基于上面一点，SPA相对服务端压力更小。
3.前后端职责分离，架构清晰。

## 缺点
1.由于单页WEB应用，需在加载渲染页面时请求JavaScript、Css文件，所以耗时更多。
2.由于前端渲染，搜索引擎不会解析JS，只能抓取首页未渲染的模板，不利于SEO。
3.由于单页应用需在一个页面显示所有的内容，默认不支持浏览器的前进后退。

缺点3，想必有人和我有同样的疑问。

通过资料查阅，其实是前端路由机制解决了单页应用无法前进后退的问题。Hash模式中Hash变化会被浏览器记录（onhashchange事件），History模式利用 H5 新增的pushState和replaceState方法可改变浏览器历史记录栈。


# new Vue(options) 都做了些什么

如下 Vue 构造函数所示，主要执行了 this._init(options)方法，该方法在initMixin函数中注册。

```javascript
import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'
import { warn } from '../util/index'

function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  // Vue.prototype._init 方法
  this._init(options)
}

// _init 方法在 initMixin 注册
initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
```

查看initMixin方法的实现，其他函数具体实现可自行查看，这里就不贴出了。

```javascript
let uid = 0
export function initMixin() {
  Vue.prototype._init = function(options) {
    const vm = this
    vm._uid = uid++
    vm._isVue = true
   
    // 处理组件配置项
    if (options && options._isComponent) {
       /**
       * 如果是子组件，走当前 if 分支
       * 函数作用是性能优化：将原型链上的方法都放到vm.$options中，减少原型链上的访问
       */   
      initInternalComponent(vm, options)
    } else {
      /**
       * 如果是根组件，走当前 else 分支
       * 合并 Vue 的全局配置到根组件中，如 Vue.component 注册的全局组件合并到根组件的 components 的选项中
       * 子组件的选项合并发生在两个地方
       * 1. Vue.component 方法注册的全局组件在注册时做了选项合并
       * 2. { component: {xx} } 方法注册的局部组件在执行编译器生成的 render 函数时做了选项合并
       */  
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
  
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }

    vm._self = vm
    /**
    * 初始化组件实例关系属性，如：$parent $root $children $refs
    */
    initLifecycle(vm)
    /**
    * 初始化自定义事件
    * <component @click="handleClick"></component>
    * 组件上注册的事件，监听者不是父组件，而是子组件本身
    */
    initEvents(vm)
    /**
    * 解析组件插槽信息，得到vm.$slot，处理渲染函数，得到 vm.$createElement 方法，即 h 函数。
    */
    initRender(vm)
    /**
    * 执行 beforeCreate 生命周期函数
    */
    callHook(vm, 'beforeCreate')
    /**
    * 解析 inject 配置项，得到 result[key] = val 的配置对象，做响应式处理且代理到 vm 实力上
    */
    initInjections(vm) 
    /**
    * 响应式处理核心，处理 props、methods、data、computed、watch
    */
    initState(vm)
    /**
    * 解析 provide 对象，并挂载到 vm 实例上
    */
    initProvide(vm) 
    /**
    * 执行 created 生命周期函数
    */
    callHook(vm, 'created')

    // 如果 el 选项，自动执行$mount
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}
```

#MVVM 的理解

MVVM是Model-View-ViewModel的缩写。Model 代表数据层，可定义修改数据、编写业务逻辑。View 代表视图层，负责将数据渲染成页面。ViewModel 负责监听数据层数据变化，控制视图层行为交互，简单讲，就是同步数据层和视图层的对象。ViewModel 通过双向绑定把 View 和 Model 层连接起来，且同步工作无需人为干涉，使开发人员只关注业务逻辑，无需频繁操作DOM，不需关注数据状态的同步问题。

## 如何实现 v-model

v-model指令用于实现input、select等表单元素的双向绑定，是个语法糖。

原生 input 元素若是text/textarea类型，使用 value 属性和 input 事件。
原生 input 元素若是radio/checkbox类型，使用 checked属性和 change 事件。
原生 select 元素，使用 value 属性和 change 事件。

input 元素上使用 v-model 等价于

```vue
<input :value="message" @input="message = $event.target.value" />
```

## 实现自定义组件的 v-model

自定义组件的v-model使用prop值为value和input事件。若是radio/checkbox类型，需要使用model来解决原生 DOM 使用的是 checked 属性 和 change 事件，如下所示。

```vue
// 父组件
<template>
  <base-checkbox v-model="baseCheck" />
</template>
```

```vue
// 子组件
<template>
  <input type="checkbox" :checked="checked" @change="$emit('change', $event.target.checked)" />
</template>
<script>
export default {
  model: {
    prop: 'checked',
    event: 'change'
  },
  prop: {
    checked: Boolean
  }
}
</script>
```



