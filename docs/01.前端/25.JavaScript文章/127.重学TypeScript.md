---
title: 重学TypeScript
date: 2022-03-06 11:50:12
permalink: /pages/5b4d22/
categories:
  - 前端
  - JavaScript文章
tags:
  - 
---

# 为什么要有 TypeScript

TypeScript是JavaScript的超集，因为它扩展了JavaScript，有JavaScript没有的东西。硬要以父子类关系来说的话，TypeScript是JavaScript子类，继承的基础上去扩展。

TypeScript诞|生的根本原因是JavaScript是弱类型语言（可以隐性的进行语言类型转变），无法做到在编译阶段进行类型检查，提早发现错误。

TypeScript的初衷就是为了做类型检查，提早发现错误，所以「类型」是其最核心的特性。当然它只是给出你代码可能不会按预期执行的警告，比如你未按照声明的类型传参，你的代码还是可以运行的。这一点与强类型语言还是有本质的区别，强类型语言会直接导致编译不通过，因为TypeScript只是转译。

跟JavaScript不同，TypeScript文件后缀使用 .ts扩展名。浏览器是不识别 .ts 文件，所以使用时必须提前把 TS 代码转换成 JavaScript 代码。这个转换过程被称为转译，编译和转译的微小差别在于：

- 编译是把源码转变成另一种语言
- 转译是把源码转变另一个相同抽象层级的语言

学习TypeScript导致了这么几个问题：

1.学习成本增加；
2.代码量增加；
3.代码复杂度增加

当然TypeScript带来的收益是可观的，静态检查使得提前发现错误，在前端工程化开发的今天确实有必要，因为团队成员技术水平参差不齐，TypeScript可以帮助避免很多错误的发生，当然如果你是any大法的信仰者，我劝你善良。不要为了用TypeScript而用TypeScript，用它的前提一定要是它能帮你解决特定的问题。

TypeScript提供最新的和不断发展的JavaScript特性，包括那些来自2015年的ECMAScript和未来的提案中的特性，比如异步功能和Decorators，以帮助建立健壮的组件。

# 正文

## 基础类型

## JS的八种内置类型

- 字符串（string）
- 数字（number）
- 布尔值（boolean）
- 未定义（undefined）
- 空值（null）
- 对象（object）
- 大整数（bigInt，ES6 新增）
- 符号（symbol，ES6 新增）

TS一一对应的example(冒号后面有无空格都可以):

```typescript
let name: string = "bob";
let age: number = 37;
let isDone: boolean = false;
let u: undefined = undefined;
let n: null = null;
let obj: object = {x: 1};
let bigLiteral: bigint = 100n;
let sym: symbol = Symbol("me");
```

## Array

对数组类型的定义有两种方式：

```typescript
// 元素类型[]
let list: number[] = [1, 2, 3];
// Array<元素类型>
let list: Array<number> = [1, 2, 3];
```

定义指定对象成员的数组：

```typescript
interface MyObject {
    name: string;
    age: number;
}

let arr: MyObject[] = [{name: "兔兔", age: 18}] // OK
```

## Tuple

上面定义数组类型的方式，只能定义出内部全为某种类型的数组。对于内部不同类型的数组可以使用元组类型来定义：

```typescript
let x: [string, number];

x = ['hello', 10]; // OK
x = [10, 'hello']; // Error
```

注意，元组类型只能表示一个已知元素数量和类型的数组，长度已指定，越界访问会提示错误。例如，一个数组中可能有多种类型，数量和类型都不确定，那就直接any[]。


## undefined和null

注意这俩比较特殊

默认情况下null和undefined是所有类型的子类型。 就是说你可以把null和undefined赋值给任何类型的变量。

```typescript
let str: string = 'hello';
str = null; // OK
str = undefined; // OK

let a: null = undefined; // OK
let b: undefined = null; // OK


```

当然也可以通过指定--strictNullChecks标记，开启严格模式检查。这种情况下，null和undefined和其他类型是平等关系，只能赋值给any和它们各自的类型，有一个例外是undefined还可以赋值给void类型（想想你为一个函数声明返回类型为void时，但函数在未显式return的情况下，默认返回的就是undefined，此时就是这个例外的表现）。



## void

void表示没有任何类型，和其他类型是平等关系，不能直接赋值:

```typescript
let a: void;
let b: number = a; // Error
```

你只能为它赋予null（只在--strictNullChecks未指定时）和undefined。声明一个void类型的变量没有什么大用，我们一般也只有在函数没有返回值时去声明。

值得注意的是，方法没有返回值将得到undefined，但是我们需要定义成void类型，而不是undefined类型。否则将报错:

```typescript
function fun(): undefined {
  console.log("this is TypeScript");
};
fun(); // Error
```

## any和unknown

any会跳过类型检查器对值的检查，任何值都可以赋值给any类型，它通常被称为top type，所以会有any大法好的说法。

```typescript
let notSure: any = 4;
notSure = "maybe a string instead"; // OK
notSure = false; // OK
```

unknown与any一样，所有类型都可以分配给unknown:

```typescript
let notSure: unknown = 4;
notSure = "maybe a string instead"; // OK
notSure = false; // OK
```

unknown与any的最大区别是：

unknown 是 top type (任何类型都是它的 subtype) , 而 any 既是 top type, 又是 bottom type (它是任何类型的 subtype ) , 这导致 any 基本上就是放弃了任何类型检查

因为any既是top type, 又是 bottom type，所以任何类型的值可以赋值给any，同时any类型的值也可以赋值给任何类型。但unknown 只是 top type，任何类型的值都可以赋值给它，但它只能赋值给unknown和any，因为只有它俩是top type。

```typescript
let notSure: unknown = 4;
let uncertain: any = notSure; // OK

let notSure: any = 4;
let uncertain: unknown = notSure; // OK

let notSure: unknown = 4;
let uncertain: number = notSure; // Error

```

如果不缩小类型，就无法对unknown类型执行任何操作：

```typescript
function getDog() {
 return '123'
}
 
const dog: unknown = {hello: getDog};
dog.hello(); // Error
```

这种机制起到了很强的预防性，更安全，这就要求我们必须缩小类型，我们可以使用typeof、类型断言等方式来缩小未知范围：

```typescript
function getDogName() {
 let x: unknown;
 return x;
};

const dogName = getDogName();

// 直接使用
const upName = dogName.toLowerCase(); // Error
 
// typeof
if (typeof dogName === 'string') {
  const upName = dogName.toLowerCase(); // OK
}

// 类型断言 
const upName = (dogName as string).toLowerCase(); // OK

```



## never

never类型表示的是那些永不存在的值的类型。

值会永不存在的两种情况：

如果一个函数执行时抛出了异常，那么这个函数永远不存在返回值（因为抛出异常会直接中断程序运行，这使得程序运行不到返回值那一步，即具有不可达的终点，也就永不存在返回了）；


函数中执行无限循环的代码（死循环），使得程序永远无法运行到函数返回值那一步，永不存在返回。

```typescript
// 异常
function err(msg: string): never { // OK
  throw new Error(msg); 
}

// 死循环
function loopForever(): never { // OK
  while (true) {};
}

```

