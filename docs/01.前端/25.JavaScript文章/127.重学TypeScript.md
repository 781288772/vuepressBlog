---
title: 重学TypeScript
date: 2022-03-06 11:50:12
permalink: /pages/5b4d22/
categories:
  - 前端
  - JavaScript文章
tags:
  - 
---

# 为什么要有 TypeScript

TypeScript是JavaScript的超集，因为它扩展了JavaScript，有JavaScript没有的东西。硬要以父子类关系来说的话，TypeScript是JavaScript子类，继承的基础上去扩展。

TypeScript诞|生的根本原因是JavaScript是弱类型语言（可以隐性的进行语言类型转变），无法做到在编译阶段进行类型检查，提早发现错误。

TypeScript的初衷就是为了做类型检查，提早发现错误，所以「类型」是其最核心的特性。当然它只是给出你代码可能不会按预期执行的警告，比如你未按照声明的类型传参，你的代码还是可以运行的。这一点与强类型语言还是有本质的区别，强类型语言会直接导致编译不通过，因为TypeScript只是转译。

跟JavaScript不同，TypeScript文件后缀使用 .ts扩展名。浏览器是不识别 .ts 文件，所以使用时必须提前把 TS 代码转换成 JavaScript 代码。这个转换过程被称为转译，编译和转译的微小差别在于：

- 编译是把源码转变成另一种语言
- 转译是把源码转变另一个相同抽象层级的语言

学习TypeScript导致了这么几个问题：

1.学习成本增加；
2.代码量增加；
3.代码复杂度增加

当然TypeScript带来的收益是可观的，静态检查使得提前发现错误，在前端工程化开发的今天确实有必要，因为团队成员技术水平参差不齐，TypeScript可以帮助避免很多错误的发生，当然如果你是any大法的信仰者，我劝你善良。不要为了用TypeScript而用TypeScript，用它的前提一定要是它能帮你解决特定的问题。

TypeScript提供最新的和不断发展的JavaScript特性，包括那些来自2015年的ECMAScript和未来的提案中的特性，比如异步功能和Decorators，以帮助建立健壮的组件。

# 正文

## 基础类型

## JS的八种内置类型

- 字符串（string）
- 数字（number）
- 布尔值（boolean）
- 未定义（undefined）
- 空值（null）
- 对象（object）
- 大整数（bigInt，ES6 新增）
- 符号（symbol，ES6 新增）

TS一一对应的example(冒号后面有无空格都可以):

```typescript
let name: string = "bob";
let age: number = 37;
let isDone: boolean = false;
let u: undefined = undefined;
let n: null = null;
let obj: object = {x: 1};
let bigLiteral: bigint = 100n;
let sym: symbol = Symbol("me");
```

## Array

对数组类型的定义有两种方式：

```typescript
// 元素类型[]
let list: number[] = [1, 2, 3];
// Array<元素类型>
let list: Array<number> = [1, 2, 3];
```

定义指定对象成员的数组：

```typescript
interface MyObject {
    name: string;
    age: number;
}

let arr: MyObject[] = [{name: "兔兔", age: 18}] // OK
```

## Tuple

上面定义数组类型的方式，只能定义出内部全为某种类型的数组。对于内部不同类型的数组可以使用元组类型来定义：

```typescript
let x: [string, number];

x = ['hello', 10]; // OK
x = [10, 'hello']; // Error
```

注意，元组类型只能表示一个已知元素数量和类型的数组，长度已指定，越界访问会提示错误。例如，一个数组中可能有多种类型，数量和类型都不确定，那就直接any[]。


## undefined和null

注意这俩比较特殊

默认情况下null和undefined是所有类型的子类型。 就是说你可以把null和undefined赋值给任何类型的变量。

```typescript
let str: string = 'hello';
str = null; // OK
str = undefined; // OK

let a: null = undefined; // OK
let b: undefined = null; // OK


```

当然也可以通过指定--strictNullChecks标记，开启严格模式检查。这种情况下，null和undefined和其他类型是平等关系，只能赋值给any和它们各自的类型，有一个例外是undefined还可以赋值给void类型（想想你为一个函数声明返回类型为void时，但函数在未显式return的情况下，默认返回的就是undefined，此时就是这个例外的表现）。



## void

void表示没有任何类型，和其他类型是平等关系，不能直接赋值:

```typescript
let a: void;
let b: number = a; // Error
```

你只能为它赋予null（只在--strictNullChecks未指定时）和undefined。声明一个void类型的变量没有什么大用，我们一般也只有在函数没有返回值时去声明。

值得注意的是，方法没有返回值将得到undefined，但是我们需要定义成void类型，而不是undefined类型。否则将报错:

```typescript
function fun(): undefined {
  console.log("this is TypeScript");
};
fun(); // Error
```

## any和unknown

any会跳过类型检查器对值的检查，任何值都可以赋值给any类型，它通常被称为top type，所以会有any大法好的说法。

```typescript
let notSure: any = 4;
notSure = "maybe a string instead"; // OK
notSure = false; // OK
```

unknown与any一样，所有类型都可以分配给unknown:

```typescript
let notSure: unknown = 4;
notSure = "maybe a string instead"; // OK
notSure = false; // OK
```

unknown与any的最大区别是：

unknown 是 top type (任何类型都是它的 subtype) , 而 any 既是 top type, 又是 bottom type (它是任何类型的 subtype ) , 这导致 any 基本上就是放弃了任何类型检查

因为any既是top type, 又是 bottom type，所以任何类型的值可以赋值给any，同时any类型的值也可以赋值给任何类型。但unknown 只是 top type，任何类型的值都可以赋值给它，但它只能赋值给unknown和any，因为只有它俩是top type。

```typescript
let notSure: unknown = 4;
let uncertain: any = notSure; // OK

let notSure: any = 4;
let uncertain: unknown = notSure; // OK

let notSure: unknown = 4;
let uncertain: number = notSure; // Error

```

如果不缩小类型，就无法对unknown类型执行任何操作：

```typescript
function getDog() {
 return '123'
}
 
const dog: unknown = {hello: getDog};
dog.hello(); // Error
```

这种机制起到了很强的预防性，更安全，这就要求我们必须缩小类型，我们可以使用typeof、类型断言等方式来缩小未知范围：

```typescript
function getDogName() {
 let x: unknown;
 return x;
};

const dogName = getDogName();

// 直接使用
const upName = dogName.toLowerCase(); // Error
 
// typeof
if (typeof dogName === 'string') {
  const upName = dogName.toLowerCase(); // OK
}

// 类型断言 
const upName = (dogName as string).toLowerCase(); // OK

```



## never

never类型表示的是那些永不存在的值的类型。

值会永不存在的两种情况：

如果一个函数执行时抛出了异常，那么这个函数永远不存在返回值（因为抛出异常会直接中断程序运行，这使得程序运行不到返回值那一步，即具有不可达的终点，也就永不存在返回了）；


函数中执行无限循环的代码（死循环），使得程序永远无法运行到函数返回值那一步，永不存在返回。

```typescript
// 异常
function err(msg: string): never { // OK
  throw new Error(msg); 
}

// 死循环
function loopForever(): never { // OK
  while (true) {};
}

```

never类型同null和undefined一样，也是任何类型的子类型，也可以赋值给任何类型：

```typescript
let err: never;
let num: number = 4;

num = err; // OK
```

但是没有类型是never的子类型或可以赋值给never类型（除了never本身之外），即使any也不可以赋值给never：

```typescript
let ne: never;
let nev: never;
let an: any;

ne = 123; // Error
ne = nev; // OK
ne = an; // Error
ne = (() => { throw new Error("异常"); })(); // OK
ne = (() => { while(true) {} })(); // OK

```

重点： never与其他类型的联合后，是没有never的

```typescript
// type Eg2 = string | number
type Eg2 = string | number | never
```

## 类型断言

类型断言好比其它语言里的类型转换，类型转换通常发生在你比TS更了解某个值的详细信息的时候。

两种方式实现：

```typescript
// 尖括号 语法
let someValue: any = "this is a string";
let strLength: number = (<string>someValue).length;

// as 语法
let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;


```

## 类型推论

如果没有明确的指定类型，那么 TypeScript 会依照类型推论的规则推断出一个类型。

```typescript
let myFavoriteNumber = 'seven';
myFavoriteNumber = 7; // Error
```

为什么是Error，因为事实上，它等价于：

```typescript
let myFavoriteNumber: string = 'seven';
myFavoriteNumber = 7; // Error
```

TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。

如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：

```typescript
let myFavoriteNumber;
myFavoriteNumber = 'seven';
myFavoriteNumber = 7;
```

## 联合类型

联合类型表示取值可以为多种类型中的一种，使用 | 分隔每个类型。

```typescript
let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven'; // OK
myFavoriteNumber = 7; // OK
```

## 交叉类型

交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性，使用&定义交叉类型。

```typescript
interface A {
  name: string,
  age: number
}
interface B {
  name: string,
  gender: string
}

let a: A & B = { // OK
    name: "兔兔",
    age: 18,
    gender: "男"
};

```

a既是A类型，同时也是B类型。

注意点：交叉类型取的多个类型的并集，但是如果key相同但是类型不同，则该key为never类型。

```typescript
type A = string & number // A 为 never 类型

let a: A = (() => {throw new Error()})(); // OK
```


## 接口

首先，通俗的理解下此处接口的概念：一般后台定义接口就是前端调用的接口，定义一些参数等，TS里的接口类似，也可以理解为定义一些参数，规定变量里面有什么参数，参数是什么类型，使用时就必须有这些对应类型的参数，少或者多参数、参数类型不对都会报错。更简单的，你可以理解为这就是在定义一个较为详细的对象类型。

第一个示例：

```typescript
function printLabel(labeledObj: { label: string }) {
  console.log(labeledObj.label);
}
let myObj = { size: 10, label: "Size 10 Object" };
printLabel(myObj); // OK

```

你懒的写interface，可以这么写。这种写法，较为宽松，只会检查那些必需的属性是否存在。

第二个示例：

```typescript
interface LabeledValue {
  label: string;
}
function printLabel(labeledObj: LabeledValue) {
  console.log(labeledObj.label);
}
let myObj = { size: 10, label: "Size 10 Object" };
printLabel(myObj); // OK


```

这种写法也是宽松的，同上也是因为发生了赋值。


注意：在 type、interface 中可以使用逗号、分号，class 中不能用逗号。不过三者都支持行结尾不要符号。


## 为什么赋值就使得类型检测变得宽松了

TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做鸭式辨型法或结构性子类型化。

所谓的鸭式辨型法就是像鸭子一样走路并且嘎嘎叫的就叫鸭子，即具有鸭子特征的认为它就是鸭子，也就是通过制定规则来判定对象是否实现这个接口(当然在TS里面不这样说)。

上面代码，在参数里写对象就相当于是直接给labeledObj赋值，这个对象有严格的类型定义，所以不能多参或少参。而当你在外面将该对象用另一个变量myObj接收，myObj不会经过额外属性检查，但会根据类型推论为let myObj: { size: number; label: string } = { size: 10, label: "Size 10 Object" };，然后将这个myObj再赋值给labeledObj，此时根据类型的兼容性，两种类型对象，参照鸭式辨型法，因为都具有label属性，所以被认定为两个相同，故而可以用此法来绕开多余的类型检查

```typescript
interface LabeledValue {
  label: string;
}
function printLabel(labeledObj: LabeledValue) {
  console.log(labeledObj.label);
}

printLabel({ size: 10, label: "Size 10 Object" }); // Error

```

