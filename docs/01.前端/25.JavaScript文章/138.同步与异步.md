同步与异步

讲到执行，那我们就要先讲到javascript里面经常提到的同步与异步啦。那么什么是同步？什么又是异步呢？

同步与异步的定义

我们传统意义上的同步是指两个或两个以上的事物随时间变化的量在变化过程中保持一定的相对关系，那么这些事物就算是同步，但是显然，我们在javascript里面所讲的同步就不是这个概念了，javascript里面，一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去，这样就称为同步，同步代码会按照一定的顺序去执行；

异步就是进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，异步在一定程度上能够大大提高代码执行的效率，但是这样讲应该还是比较晦涩难懂，那不妨往下看看异步是如何实现的。

如何实现异步？

    实现异步的方法很多，常用的有以下几种：

      1、使用setTimeout方法；
      2、使用setImmediate 方法；
      3、使用requestAnimationFrame方法；

接下来我就简单带着大家用setTimeout方法去实现异步：

```
function a(){
    console.log('aaa');
}

function b(){
    setTimeout(() => {
        console.log('bbb');
    },1000);
}

function c(){
    console.log('ccc');
}

a();
b();
c();

```

正常来说，当a()函数被调用结束后，应该是b()函数被调用，而b函数里应该是先执行完定时器setTimeout函数里面的console.log('bbb')再去调用最后一个函数c();

可是可以看到我们console.log打印出来的顺序是aaa->ccc->bbb;这说明什么？是b（）函数在c（）函数后面执行吗？错！不是，是当执行到setTimeout定时器函数时，定时器延时1s才开始执行里面的内容，所以浏览器默认往下继续执行，实际上定时器确实是已经执行过了，只不过延时了，那么c()函数就相当于变相的提前了，这就是异步；

如何解决异步？

如果我们就要c函数在b函数后面执行，那么有去除异步的办法吗？答案是有的；在E6之前我们是通过回调的方式去调用函数，来控制函数执行的先后顺序；

```javascript
unction a(){
    console.log('aaa');
}

function b(cb){
    setTimeout(() => {
        console.log('bbb');
        cb();
    },1000);
}

function c(){
    console.log('ccc');
}

a();
b(c);   

```

在此，我们在原代码的基础上去做修改，把c函数放在b函数内进行调用，从而回调，让c函数达到在b函数的后面执行的效果。

回调地狱

但是值得注意的是，回调函数嵌套过多，代码逻辑过于复杂就容易造成回调地狱；那么什么是回调地狱呢？假如说我们存在很多个函数，而c函数放在b函数里执行，d函数在c函数里面执行，e函数在d函数里面执行，以此类推，一直这样回调，那么回调函数就会形成一个回调链，而执行上下文的内存无法得到释放，一旦到了一个极限，就会形成回调地狱。

所以我不推荐使用回调去达到去除异步的效果，接下来我会带大家去看另外一个方法：promise方法。

Promise方法

promise方法是ES6之后推出的一个新方法，它是异步编程的一种解决方案，是一个对象，可以获取异步操作的消息，大大改善了异步编程的困难，避免了回调地狱，比传统的解决方案回调函数和事件更合理和更强大。

假设咱们写两个函数，分别代表着一个人相亲和结婚；其中相亲花了两天，而结婚花了一天：  

```
function xq(){
    setTimeout(()=>{
        console.log('周公子相亲了！');
    },2000)
}
function marry(){
    setTimeout(()=>{
        console.log('周公子结婚了！');
    },1000)
}
xq();
marry();

```

可这么一段函数执行下来却不太如我们所愿，变成了先结婚再相亲，而原因则是两个函数发生了异步；

可这样先结婚还去相亲可不就是渣男行为嘛，咱们这里就用上新方法promise方法去解决异步问题，让它按照我们想要先相亲再结婚的方向去执行。

```
function xq(){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            console.log('周公子相亲了！');
            resolve('ok')
        },2000)
    })
}
function marry(){
    setTimeout(()=>{
        console.log('周公子结婚了！');
    },1000)
}
xq().then(marry)

```

promise函数是一个对象，它自带两个参数，一个resolve，一个reject；当函数读取成功了，就会返回resolve，失败了就会返回reject；这里咱们只是用到了resolve，然后在调用后面.then()就可以很好的去解决异步这个问题了

then方法的返回结果是新的Promise实例，对象状态由回调函数的执行结果决定。then方法后面还可以再调用另一个then方法，形成链条。采用链式的then，可以指定一组按照次序调用的回调函数。

Promise函数的其它方法

Promise.prototype.catch()；

Promise.prototype.finally()；

Promise.resolve()；

Promise.reject()；

Promise.all()；

Promise.race()；



Event—Loop

在谈事件循环之前，我们先来看这么一段代码吧

```
console.log('start');

setTimeout(function(){
    console.log('setTimeout');
},0)

new Promise(resolve =>{
    console.log('Promise');
    resolve();
})
    .then(function(){
        console.log('promise1');
    })
    .then(function(){
        console.log('promise2');
    })
    
console.log('end');

```

这里你们能知道这段代码的打印顺序应该是怎么样的吗？

这里我先把它的执行顺序告诉大家，至于为什么，当大家看完后面的内容再回来看相信就能知道了


start -> Promise -> end -> promise1 -> promise2 -> setTimeout

首先我们要了解javascript是一个单线程的脚本语言，也就是说我们在执行代码的过程中不会出现同时进行两个进程（执行两段代码块）

可大家还是会好奇，可这也跟事件循环没有关系啊？别急，在了解事件循环之前，我们还得知道一些小知识；