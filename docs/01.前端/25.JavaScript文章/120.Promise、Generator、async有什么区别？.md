# 前言

我们知道Promise与Async/await函数都是用来解决JavaScript中的异步问题的，从最开始的回调函数处理异步，到Promise处理异步，到Generator处理异步，再到Async/await处理异步，每一次的技术更新都使得JavaScript处理异步的方式更加优雅，从目前来看，Async/await被认为是异步处理的终极解决方案，让JS的异步处理越来越像同步任务。「异步编程的最高境界，就是根本不用关心它是不是异步」。

# 异步解决方案的发展历程

## 1.回调函数

从早期的Javascript代码来看，在ES6诞生之前，基本上所有的异步处理都是基于回调函数函数实现的，你们可能会见过下面这种代码：

```javascript
ajax('aaa', () => {
    // callback 函数体
    ajax('bbb', () => {
        // callback 函数体
        ajax('ccc', () => {
            // callback 函数体
        })
    })
})
```

没错，在ES6出现之前，这种代码可以说是随处可见。它虽然解决了异步执行的问题，可随之而来的是我们常听说的「回调地狱」问题：

- 没有顺序可言：嵌套函数执行带来的是调试困难，不利于维护与阅读
- 耦合性太强：一旦某一个嵌套层级有改动，就会影响整个回调的执行

「所以，为了解决这个问题，社区最早提出和实现了Promise，ES6将其写进了语言标准，统一了用法。」

## 2.Promise

Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它就是为了解决回调函数产生的问题而诞生的。

有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。

所以上面那种回调函数的方式我们可以改成这样：(前提是ajax已用Promise包装)

```javascript
ajax('aaa').then(res=>{
  return ajax('bbb')
}).then(res=>{
  return ajax('ccc')
})
```


