# 六千字详解！讲透 Vue3 响应式是如何实现的

# 前言

本文使用 ref 对 vue 的响应性进行解读，仅仅是响应性原理解析，不涉及 vue 组件等概念。

vue 的响应性的实现，在 @vue/reactivity 包下，对应的源码目录为 packages/reactivity。如何调试 vue 源码，

## 为什么使用 ref 进行讲解，而不是 reactive？

ref 比 reactive 的实现简单，且不需要用到 es6 的 Proxy，仅仅需要使用到对象的 getter 和 setter 函数

因此，讲述响应性原理，我们用简单的 ref ，尽量减少大家的理解成本

# 什么是响应性？

这个术语在程序设计中经常被提及，但这是什么意思呢？响应性是一种允许我们以声明式的方式去适应变化的编程范例。人们通常展示的典型例子，是一份 excel 电子表格 (一个非常好的例子)

如果将数字 2 放在第一个单元格中，将数字 3 放在第二个单元格中并要求提供 SUM，则电子表格会将其计算出来给你。不要惊奇，同时，如果你更新第一个数字，SUM 也会自动更新。

JavaScript 通常不是这样工作的——如果我们想用 JavaScript 编写类似的内容：

```javascript
let val1 = 2;
let val2 = 3;
let sum = val1 + val2;

console.log(sum); // 5

val1 = 3;

console.log(sum); // 仍然是 5
```

如果我们更新第一个值，sum 不会被修改。

那么我们如何用 JavaScript 实现这一点呢？

我们这里直接看 @vue/reactive 的测试用例，来看看怎么使用，才会做到响应性的效果

# ref 的测试用例

it 包裹的是测试用例的具体内容，我们只需要关注回调里面的代码即可。

```javascript
it("should be reactive", () => {
  const a = ref(1);
  let dummy;
  let calls = 0;
  effect(() => {
    calls++;
    dummy = a.value;
  });
  expect(calls).toBe(1);
  expect(dummy).toBe(1);
  a.value = 2;
  expect(calls).toBe(2);
  expect(dummy).toBe(2);
  // same value should not trigger
  a.value = 2;
  expect(calls).toBe(2);
  expect(dummy).toBe(2);
});
```

我们从测试用例中，可以看出有以下几点结论：

- 被 effect 包裹的函数，会自动执行一次。

- 被 effect 函数包裹的函数体，拥有了响应性 —— 当 effect 内的函数中的 ref 对象 a.value 被修改时，该函数会自动重新执行。

- 当 a.value 被设置成同一个值时，函数并不会自动的重新执行。
